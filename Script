-- Enhanced Character Tracker with Real-Time JSON Updates and Improved Auto-Buy
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local SoundService = game:GetService("SoundService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- Record join time for session tracking
local joinTime = os.time()

-- Auto-buy settings
local autoBuyEnabled = false
local purchaseDistance = 10
local purchaseDuration = 2.5
local followUpdateInterval = 0.1
local maxFollowTime = 60 -- Increased timeout for better tracking

-- Track current target and purchase state
local currentTarget = nil
local isPurchasing = false
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

-- Character data (in the requested order)
local characterNames = {
    "Timeskip Hinata",
    "Awakened Tobio Kageyama",
    "Awakened Kiyoomi Sakusa",
    "Awakened Korai Hoshiumi",
    "Awakened Wakatoshi Ushijima",
    "Shinsuke Kita",
    "Tobio Kageyama",
    "Korai Hoshiumi",
    "Wakatoshi Ushijima",
    "Kiyoomi Sakusa",
    "Keiji Akaashi",
    "Takanobu Aone",
    "Tetsuro Kuroo",
    "Alt Art MSBY Atsumu",
    "Kotaro Bokuto",
    "Oikawa",
    "Koshi Sugawara",
    "Kenma Kozume",
    "Yaku Morisuke",
    "Yamaguchi",
    "Satori Tendo",
    "Daichi Sawamura",
    "Rintaro Suna",
    "Atsumu Miya",
    "Kei Tsukishima",
    "Shoyo Hinata",
    "Hajime Iwaizumi",
    "Kentaro Kyotani",
    "Yuu Nishinoya",
    "Taketora Yamamoto",
    "Lev Haiba",
    "Komori Motoya",
    "Golden Timeskip Hinata",
    "Golden Awakened Tobio Kageyama",
    "Golden Awakened Kiyoomi Sakusa",
    "Golden Awakened Korai Hoshiumi",
    "Golden Awakened Wakatoshi Ushijima",
    "Golden Shinsuke Kita",
    "Golden Tobio Kageyama",
    "Golden Korai Hoshiumi",
    "Golden Wakatoshi Ushijima",
    "Golden Kiyoomi Sakusa",
    "Golden Keiji Akaashi",
    "Golden Takanobu Aone",
    "Golden Tetsuro Kuroo",
    "Golden Alt Art MSBY Atsumu",
    "Golden Kotaro Bokuto",
    "Golden Oikawa",
    "Golden Koshi Sugawara",
    "Golden Kenma Kozume",
    "Golden Yaku Morisuke",
    "Golden Yamaguchi",
    "Golden Satori Tendo",
    "Golden Daichi Sawamura",
    "Golden Rintaro Suna",
    "Golden Atsumu Miya",
    "Golden Kei Tsukishima",
    "Golden Shoyo Hinata",
    "Golden Hajime Iwaizumi",
    "Golden Kentaro Kyotani",
    "Golden Yuu Nishinoya",
    "Golden Taketora Yamamoto",
    "Golden Lev Haiba",
    "Golden Komori Motoya",
    "Diamond Timeskip Hinata",
    "Diamond Awakened Tobio Kageyama",
    "Diamond Awakened Kiyoomi Sakusa",
    "Diamond Awakened Korai Hoshiumi",
    "Diamond Awakened Wakatoshi Ushijima",
    "Diamond Shinsuke Kita",
    "Diamond Tobio Kageyama",
    "Diamond Korai Hoshiumi",
    "Diamond Wakatoshi Ushijima",
    "Diamond Kiyoomi Sakusa",
    "Diamond Keiji Akaashi",
    "Diamond Takanobu Aone",
    "Diamond Tetsuro Kuroo",
    "Diamond Alt Art MSBY Atsumu",
    "Diamond Kotaro Bokuto",
    "Diamond Oikawa",
    "Diamond Koshi Sugawara",
    "Diamond Kenma Kozume",
    "Diamond Yaku Morisuke",
    "Diamond Yamaguchi",
    "Diamond Satori Tendo",
    "Diamond Daichi Sawamura",
    "Diamond Rintaro Suna",
    "Diamond Atsumu Miya",
    "Diamond Kei Tsukishima",
    "Diamond Shoyo Hinata",
    "Diamond Hajime Iwaizumi",
    "Diamond Kentaro Kyotani",
    "Diamond Yuu Nishinoya",
    "Diamond Taketora Yamamoto",
    "Diamond Lev Haiba",
    "Diamond Komori Motoya"
}

-- Function to shorten display names
local function shortenName(name)
    name = name:gsub("Golden", "Gold")
    name = name:gsub("Diamond", "Dia")
    
    -- Special handling for long names
    if name == "Awakened Wakatoshi Ushijima" then
        return "Awakened Wakatoshi Ushijima"
    elseif name == "Golden Awakened Tobio Kageyama" then
        return "Gold Awakened Tobio Kageyama"
    elseif name == "Golden Awakened Kiyoomi Sakusa" then
        return "Gold Awakened Kiyoomi Sakusa"
    elseif name == "Golden Awakened Korai Hoshiumi" then
        return "Gold Awakened Korai Hoshiumi"
    elseif name == "Golden Awakened Wakatoshi Ushijima" then
        return "Gold Awakened Wakatoshi Ushijima"
    elseif name == "Diamond Awakened Tobio Kageyama" then
        return "Dia Awakened Tobio Kageyama"
    elseif name == "Diamond Awakened Kiyoomi Sakusa" then
        return "Dia Awakened Kiyoomi Sakusa"
    elseif name == "Diamond Awakened Korai Hoshiumi" then
        return "Dia Awakened Korai Hoshiumi"
    elseif name == "Diamond Awakened Wakatoshi Ushijima" then
        return "Dia Awakened Wakatoshi Ushijima"
    elseif name == "Alt Art MSBY Atsumu" then
        return "Alt Art Atsumu"
    elseif name == "Golden Alt Art MSBY Atsumu" then
        return "Gold Alt Art Atsumu"
    elseif name == "Diamond Alt Art MSBY Atsumu" then
        return "Dia Alt Art Atsumu"
    end
    
    return name
end

-- Function to play alarm sound
local function playAlarmSound()
    pcall(function()
        -- Create a sound instance
        local sound = Instance.new("Sound")
        
        -- Use the alarm sound from the provided asset ID
        sound.SoundId = "http://www.roblox.com/asset/?id=5476307813"
        
        sound.Volume = 0.7
        sound.Parent = SoundService
        
        -- Wait for the sound to load
        sound.Loaded:Wait()
        
        -- Play the sound
        sound:Play()
        
        -- Clean up after the sound finishes
        sound.Ended:Connect(function()
            sound:Destroy()
        end)
        
        -- Safety cleanup in case the sound doesn't end properly
        delay(10, function()
            if sound and sound.Parent then
                sound:Destroy()
            end
        end)
    end)
end

-- File-based saving functions
local function getSavePath()
    -- Try to get the executor's workspace path
    local workspacePath = nil
    
    -- Try different methods to get the workspace path
    if pcall(function() workspacePath = getexecutordirectory() end) and workspacePath then
        return workspacePath .. "/Steal a Haikyu Script/character_states.json"
    elseif pcall(function() workspacePath = getscriptsdirectory() end) and workspacePath then
        return workspacePath .. "/../Steal a Haikyu Script/character_states.json"
    else
        -- Fallback to a relative path
        return "Steal a Haikyu Script/character_states.json"
    end
end

-- Load saved character states
local function loadCharacterStates()
    local savePath = getSavePath()
    local defaultStates = {}
    
    -- Set default states - only the specified characters are true by default
    local defaultTrueCharacters = {
        "Timeskip Hinata",
        "Awakened Tobio Kageyama",
        "Awakened Kiyoomi Sakusa",
        "Awakened Korai Hoshiumi",
        "Awakened Wakatoshi Ushijima",
        "Golden Timeskip Hinata",
        "Golden Awakened Tobio Kageyama",
        "Golden Awakened Kiyoomi Sakusa",
        "Golden Awakened Korai Hoshiumi",
        "Golden Awakened Wakatoshi Ushijima",
        "Diamond Timeskip Hinata",
        "Diamond Awakened Tobio Kageyama",
        "Diamond Awakened Kiyoomi Sakusa",
        "Diamond Awakened Korai Hoshiumi",
        "Diamond Awakened Wakatoshi Ushijima"
    }
    
    -- Set all characters to false by default
    for _, name in ipairs(characterNames) do
        defaultStates[name] = false
    end
    
    -- Set the specified characters to true
    for _, name in ipairs(defaultTrueCharacters) do
        defaultStates[name] = true
    end
    
    -- Check if file exists before trying to read it
    local fileExists = pcall(function()
        if readfile and isfile then
            return isfile(savePath)
        end
        return false
    end)
    
    if fileExists then
        -- Try to read the file
        local success, fileContents = pcall(function()
            return readfile(savePath)
        end)
        
        if success and fileContents then
            -- Try to parse the JSON
            local success2, parsedData = pcall(function()
                return game:GetService("HttpService"):JSONDecode(fileContents)
            end)
            
            if success2 and parsedData then
                print("Loaded character states from file")
                
                -- Merge with defaults for any missing characters
                for _, name in ipairs(characterNames) do
                    if parsedData[name] == nil then
                        parsedData[name] = defaultStates[name]
                    end
                end
                
                return parsedData
            else
                print("Failed to parse saved character states, using defaults")
            end
        else
            print("Failed to read saved character states, using defaults")
        end
    else
        print("No saved character states found, using defaults")
    end
    
    -- If we couldn't load the file, create the directory and return default states
    pcall(function()
        makefolder("Steal a Haikyu Script")
    end)
    
    return defaultStates
end

-- Save character states
local function saveCharacterStates(states)
    local savePath = getSavePath()
    
    -- Ensure the directory exists
    pcall(function()
        makefolder("Steal a Haikyu Script")
    end)
    
    -- Try to save the file
    local success, err = pcall(function()
        local jsonData = game:GetService("HttpService"):JSONEncode(states)
        writefile(savePath, jsonData)
        print("Character states saved to file")
    end)
    
    if not success then
        print("Failed to save character states: " .. tostring(err))
    end
end

-- Initialize character data with saved states
local savedStates = loadCharacterStates()
local characterData = {}
local characterFrames = {}

for _, name in ipairs(characterNames) do
    characterData[name] = {
        enabled = savedStates[name] ~= nil and savedStates[name] or false,
        currentCount = 0,
        totalCount = 0,
        lastPresentTime = nil,
        status = "never"
    }
end

-- Create main screen GUI
local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CharacterTracker"
screenGui.Parent = playerGui
screenGui.ResetOnSpawn = false

-- Main container frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 700, 0, 460)
mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
mainFrame.BackgroundColor3 = Color3.fromRGB(22, 36, 71)
mainFrame.BorderSizePixel = 0
mainFrame.ClipsDescendants = true
mainFrame.Parent = screenGui

-- Header
local header = Instance.new("Frame")
header.Name = "Header"
header.Size = UDim2.new(1, 0, 0, 40)
header.Position = UDim2.new(0, 0, 0, 0)
header.BackgroundColor3 = Color3.fromRGB(15, 52, 96)
header.BorderSizePixel = 0
header.Parent = mainFrame

local title = Instance.new("TextLabel")
title.Name = "Title"
title.Size = UDim2.new(1, -50, 1, 0)
title.Position = UDim2.new(0, 10, 0, 0)
title.BackgroundTransparency = 1
title.Text = "Character Presence Tracker"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.GothamBold
title.TextSize = 16
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = header

-- Circular auto-buy toggle in top right corner
local autoBuyButton = Instance.new("TextButton")
autoBuyButton.Name = "AutoBuyButton"
autoBuyButton.Size = UDim2.new(0, 30, 0, 30)
autoBuyButton.Position = UDim2.new(1, -35, 0, 5)
autoBuyButton.AnchorPoint = Vector2.new(1, 0)
autoBuyButton.BackgroundColor3 = Color3.fromRGB(220, 53, 53) -- Red when off
autoBuyButton.Text = ""
autoBuyButton.Parent = header

-- Make it circular
autoBuyButton.AutoButtonColor = false
local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(1, 0)
corner.Parent = autoBuyButton

-- Add a status indicator inside the circle
local statusIndicator = Instance.new("Frame")
statusIndicator.Name = "StatusIndicator"
statusIndicator.Size = UDim2.new(0, 20, 0, 20)
statusIndicator.Position = UDim2.new(0.5, -10, 0.5, -10)
statusIndicator.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
statusIndicator.BorderSizePixel = 0
statusIndicator.Parent = autoBuyButton

local statusCorner = Instance.new("UICorner")
statusCorner.CornerRadius = UDim.new(1, 0)
statusCorner.Parent = statusIndicator

-- Tooltip for the button
autoBuyButton.MouseEnter:Connect(function()
    local tooltip = Instance.new("TextLabel")
    tooltip.Name = "Tooltip"
    tooltip.Size = UDim2.new(0, 100, 0, 25)
    tooltip.Position = UDim2.new(0, 0, -1, -5)
    tooltip.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    tooltip.Text = "Auto-Buy: " .. (autoBuyEnabled and "ON" or "OFF")
    tooltip.TextColor3 = Color3.fromRGB(255, 255, 255)
    tooltip.Font = Enum.Font.Gotham
    tooltip.TextSize = 12
    tooltip.Parent = autoBuyButton
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 4)
    corner.Parent = tooltip
end)

autoBuyButton.MouseLeave:Connect(function()
    if autoBuyButton:FindFirstChild("Tooltip") then
        autoBuyButton.Tooltip:Destroy()
    end
end)

-- Search box at the top
local searchBox = Instance.new("TextBox")
searchBox.Name = "SearchBox"
searchBox.Size = UDim2.new(1, -20, 0, 30)
searchBox.Position = UDim2.new(0, 10, 0, 45)
searchBox.BackgroundColor3 = Color3.fromRGB(45, 80, 130)
searchBox.PlaceholderText = "Search characters..."
searchBox.Text = ""
searchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
searchBox.Font = Enum.Font.Gotham
searchBox.TextSize = 14
searchBox.Parent = mainFrame

-- Characters panel
local charactersPanel = Instance.new("Frame")
charactersPanel.Name = "CharactersPanel"
charactersPanel.Size = UDim2.new(0, 250, 0, 310)
charactersPanel.Position = UDim2.new(0, 0, 0, 80)
charactersPanel.BackgroundColor3 = Color3.fromRGB(31, 64, 104)
charactersPanel.BorderSizePixel = 0
charactersPanel.ClipsDescendants = true
charactersPanel.Parent = mainFrame

local charactersScrolling = Instance.new("ScrollingFrame")
charactersScrolling.Name = "CharactersScrolling"
charactersScrolling.Size = UDim2.new(1, 0, 1, -30)
charactersScrolling.Position = UDim2.new(0, 0, 0, 30)
charactersScrolling.BackgroundTransparency = 1
charactersScrolling.BorderSizePixel = 0
charactersScrolling.ScrollBarThickness = 6
charactersScrolling.CanvasSize = UDim2.new(0, 0, 0, 0)
charactersScrolling.Parent = charactersPanel

-- Characters title
local charactersTitle = Instance.new("TextLabel")
charactersTitle.Name = "CharactersTitle"
charactersTitle.Size = UDim2.new(1, -20, 0, 25)
charactersTitle.Position = UDim2.new(0, 10, 0, 5)
charactersTitle.BackgroundTransparency = 1
charactersTitle.Text = "Characters"
charactersTitle.TextColor3 = Color3.fromRGB(255, 255, 255)
charactersTitle.Font = Enum.Font.GothamBold
charactersTitle.TextSize = 14
charactersTitle.TextXAlignment = Enum.TextXAlignment.Left
charactersTitle.Parent = charactersPanel

-- Tracking panel
local trackingPanel = Instance.new("Frame")
trackingPanel.Name = "TrackingPanel"
trackingPanel.Size = UDim2.new(0, 430, 0, 310)
trackingPanel.Position = UDim2.new(0, 260, 0, 80)
trackingPanel.BackgroundTransparency = 1
trackingPanel.BorderSizePixel = 0
trackingPanel.ClipsDescendants = true
trackingPanel.Parent = mainFrame

local trackingScrolling = Instance.new("ScrollingFrame")
trackingScrolling.Name = "TrackingScrolling"
trackingScrolling.Size = UDim2.new(1, 0, 1, -30)
trackingScrolling.Position = UDim2.new(0, 0, 0, 30)
trackingScrolling.BackgroundTransparency = 1
trackingScrolling.BorderSizePixel = 0
trackingScrolling.ScrollBarThickness = 6
trackingScrolling.CanvasSize = UDim2.new(0, 0, 0, 0)
trackingScrolling.Parent = trackingPanel

-- Header for tracking panel
local trackingHeader = Instance.new("Frame")
trackingHeader.Name = "TrackingHeader"
trackingHeader.Size = UDim2.new(1, -10, 0, 25)
trackingHeader.Position = UDim2.new(0, 5, 0, 5)
trackingHeader.BackgroundColor3 = Color3.fromRGB(15, 52, 96)
trackingHeader.BorderSizePixel = 0
trackingHeader.Parent = trackingPanel

-- Adjusted column widths to accommodate longer names
local nameHeader = Instance.new("TextLabel")
nameHeader.Name = "NameHeader"
nameHeader.Size = UDim2.new(0.45, 0, 1, 0)
nameHeader.Position = UDim2.new(0, 5, 0, 0)
nameHeader.BackgroundTransparency = 1
nameHeader.Text = "Character"
nameHeader.TextColor3 = Color3.fromRGB(255, 255, 255)
nameHeader.Font = Enum.Font.GothamBold
nameHeader.TextSize = 12
nameHeader.TextXAlignment = Enum.TextXAlignment.Left
nameHeader.Parent = trackingHeader

local statusHeader = Instance.new("TextLabel")
statusHeader.Name = "StatusHeader"
statusHeader.Size = UDim2.new(0.2, 0, 1, 0)
statusHeader.Position = UDim2.new(0.45, 0, 0, 0)
statusHeader.BackgroundTransparency = 1
statusHeader.Text = "Status"
statusHeader.TextColor3 = Color3.fromRGB(255, 255, 255)
statusHeader.Font = Enum.Font.GothamBold
statusHeader.TextSize = 12
statusHeader.Parent = trackingHeader

local countHeader = Instance.new("TextLabel")
countHeader.Name = "CountHeader"
countHeader.Size = UDim2.new(0.15, 0, 1, 0)
countHeader.Position = UDim2.new(0.65, 0, 0, 0)
countHeader.BackgroundTransparency = 1
countHeader.Text = "Count"
countHeader.TextColor3 = Color3.fromRGB(255, 255, 255)
countHeader.Font = Enum.Font.GothamBold
countHeader.TextSize = 12
countHeader.Parent = trackingHeader

local timeHeader = Instance.new("TextLabel")
timeHeader.Name = "TimeHeader"
timeHeader.Size = UDim2.new(0.2, 0, 1, 0)
timeHeader.Position = UDim2.new(0.8, 0, 0, 0)
timeHeader.BackgroundTransparency = 1
timeHeader.Text = "Time"
timeHeader.TextColor3 = Color3.fromRGB(255, 255, 255)
timeHeader.Font = Enum.Font.GothamBold
timeHeader.TextSize = 12
timeHeader.Parent = trackingHeader

-- Footer - Increased height to fit session time and auto-buy status
local footer = Instance.new("Frame")
footer.Name = "Footer"
footer.Size = UDim2.new(1, 0, 0, 50)  -- Increased height to 50
footer.Position = UDim2.new(0, 0, 0, 400)  -- Adjusted position
footer.BackgroundColor3 = Color3.fromRGB(15, 52, 96)
footer.BorderSizePixel = 0
footer.Parent = mainFrame

local lastUpdate = Instance.new("TextLabel")
lastUpdate.Name = "LastUpdate"
lastUpdate.Size = UDim2.new(0.5, -20, 0, 20)
lastUpdate.Position = UDim2.new(0, 10, 0, 0)
lastUpdate.BackgroundTransparency = 1
lastUpdate.Text = "Last updated: Just now"
lastUpdate.TextColor3 = Color3.fromRGB(160, 160, 160)
lastUpdate.Font = Enum.Font.Gotham
lastUpdate.TextSize = 12
lastUpdate.TextXAlignment = Enum.TextXAlignment.Left
lastUpdate.Parent = footer

-- Session time label
local sessionTime = Instance.new("TextLabel")
sessionTime.Name = "SessionTime"
sessionTime.Size = UDim2.new(0.5, -20, 0, 20)
sessionTime.Position = UDim2.new(0, 10, 0, 20)
sessionTime.BackgroundTransparency = 1
sessionTime.Text = "Session: 0m 0s"
sessionTime.TextColor3 = Color3.fromRGB(160, 160, 160)
sessionTime.Font = Enum.Font.Gotham
sessionTime.TextSize = 12
sessionTime.TextXAlignment = Enum.TextXAlignment.Left
sessionTime.Parent = footer

-- Auto-buy status label
local autoBuyStatus = Instance.new("TextLabel")
autoBuyStatus.Name = "AutoBuyStatus"
autoBuyStatus.Size = UDim2.new(0.5, -20, 0, 20)
autoBuyStatus.Position = UDim2.new(0.5, 10, 0, 0)
autoBuyStatus.BackgroundTransparency = 1
autoBuyStatus.Text = "Auto-Buy: Idle"
autoBuyStatus.TextColor3 = Color3.fromRGB(160, 160, 160)
autoBuyStatus.Font = Enum.Font.Gotham
autoBuyStatus.TextSize = 12
autoBuyStatus.TextXAlignment = Enum.TextXAlignment.Right
autoBuyStatus.Parent = footer

-- Target status label
local targetStatus = Instance.new("TextLabel")
targetStatus.Name = "TargetStatus"
targetStatus.Size = UDim2.new(0.5, -20, 0, 20)
targetStatus.Position = UDim2.new(0.5, 10, 0, 20)
targetStatus.BackgroundTransparency = 1
targetStatus.Text = "Target: None"
targetStatus.TextColor3 = Color3.fromRGB(160, 160, 160)
targetStatus.Font = Enum.Font.Gotham
targetStatus.TextSize = 12
targetStatus.TextXAlignment = Enum.TextXAlignment.Right
targetStatus.Parent = footer

-- Loading indicator
local loadingFrame = Instance.new("Frame")
loadingFrame.Name = "LoadingFrame"
loadingFrame.Size = UDim2.new(1, 0, 1, 0)
loadingFrame.Position = UDim2.new(0, 0, 0, 0)
loadingFrame.BackgroundColor3 = Color3.fromRGB(22, 36, 71)
loadingFrame.BorderSizePixel = 0
loadingFrame.ZIndex = 10
loadingFrame.Parent = mainFrame

local loadingText = Instance.new("TextLabel")
loadingText.Name = "LoadingText"
loadingText.Size = UDim2.new(1, 0, 0, 30)
loadingText.Position = UDim2.new(0, 0, 0.5, -15)
loadingText.BackgroundTransparency = 1
loadingText.Text = "Loading character data..."
loadingText.TextColor3 = Color3.fromRGB(255, 255, 255)
loadingText.Font = Enum.Font.GothamBold
loadingText.TextSize = 16
loadingText.Parent = loadingFrame

-- Script loaded flag
local scriptLoaded = false

-- Create UI elements for characters
local function initializeUI()
    -- Create checkboxes for each character in characters panel
    for i, name in ipairs(characterNames) do
        local checkboxFrame = Instance.new("Frame")
        checkboxFrame.Name = name .. "Checkbox"
        checkboxFrame.Size = UDim2.new(1, -20, 0, 20)
        checkboxFrame.Position = UDim2.new(0, 10, 0, 5 + (i-1)*25)
        checkboxFrame.BackgroundTransparency = 1
        checkboxFrame.Parent = charactersScrolling
        
        local checkbox = Instance.new("TextButton")
        checkbox.Name = "Checkbox"
        checkbox.Size = UDim2.new(0, 15, 0, 15)
        checkbox.Position = UDim2.new(0, 0, 0.5, -7.5)
        checkbox.BackgroundColor3 = characterData[name].enabled and Color3.fromRGB(76, 175, 80) or Color3.fromRGB(158, 158, 158)
        checkbox.Text = ""
        checkbox.Parent = checkboxFrame
        
        local nameLabel = Instance.new("TextLabel")
        nameLabel.Name = "NameLabel"
        nameLabel.Size = UDim2.new(1, -25, 1, 0)
        nameLabel.Position = UDim2.new(0, 20, 0, 0)
        nameLabel.BackgroundTransparency = 1
        nameLabel.Text = shortenName(name)
        nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        nameLabel.Font = Enum.Font.Gotham
        nameLabel.TextSize = 11
        nameLabel.TextXAlignment = Enum.TextXAlignment.Left
        nameLabel.TextTruncate = Enum.TextTruncate.AtEnd
        nameLabel.Parent = checkboxFrame
        
        -- Create tracking row
        local rowFrame = Instance.new("Frame")
        rowFrame.Name = name .. "Row"
        rowFrame.Size = UDim2.new(1, -10, 0, 25)
        rowFrame.Position = UDim2.new(0, 5, 0, 5 + (i-1)*28)
        rowFrame.BackgroundColor3 = Color3.fromRGB(31, 64, 104)
        rowFrame.Visible = characterData[name].enabled
        rowFrame.Parent = trackingScrolling
        
        local rowName = Instance.new("TextLabel")
        rowName.Name = "RowName"
        rowName.Size = UDim2.new(0.45, 0, 1, 0)
        rowName.Position = UDim2.new(0, 5, 0, 0)
        rowName.BackgroundTransparency = 1
        rowName.Text = shortenName(name)
        rowName.TextColor3 = Color3.fromRGB(255, 255, 255)
        rowName.Font = Enum.Font.Gotham
        rowName.TextSize = 11
        rowName.TextXAlignment = Enum.TextXAlignment.Left
        rowName.TextTruncate = Enum.TextTruncate.AtEnd
        rowName.Parent = rowFrame
        
        local statusIndicator = Instance.new("Frame")
        statusIndicator.Name = "StatusIndicator"
        statusIndicator.Size = UDim2.new(0, 10, 0, 10)
        statusIndicator.Position = UDim2.new(0.45, 5, 0.5, -5)
        statusIndicator.BackgroundColor3 = Color3.fromRGB(158, 158, 158)
        statusIndicator.Parent = rowFrame
        
        local statusLabel = Instance.new("TextLabel")
        statusLabel.Name = "StatusLabel"
        statusLabel.Size = UDim2.new(0.2, -15, 1, 0)
        statusLabel.Position = UDim2.new(0.45, 20, 0, 0)
        statusLabel.BackgroundTransparency = 1
        statusLabel.Text = "Never seen"
        statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        statusLabel.Font = Enum.Font.Gotham
        statusLabel.TextSize = 11
        statusLabel.TextTruncate = Enum.TextTruncate.AtEnd
        statusLabel.Parent = rowFrame
        
        local countLabel = Instance.new("TextLabel")
        countLabel.Name = "CountLabel"
        countLabel.Size = UDim2.new(0.15, 0, 1, 0)
        countLabel.Position = UDim2.new(0.65, 0, 0, 0)
        countLabel.BackgroundTransparency = 1
        countLabel.Text = "0"
        countLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        countLabel.Font = Enum.Font.Gotham
        countLabel.TextSize = 11
        countLabel.Parent = rowFrame
        
        local timeLabel = Instance.new("TextLabel")
        timeLabel.Name = "TimeLabel"
        timeLabel.Size = UDim2.new(0.2, 0, 1, 0)
        timeLabel.Position = UDim2.new(0.8, 0, 0, 0)
        timeLabel.BackgroundTransparency = 1
        timeLabel.Text = "-"
        timeLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
        timeLabel.Font = Enum.Font.Gotham
        timeLabel.TextSize = 11
        timeLabel.TextTruncate = Enum.TextTruncate.AtEnd
        timeLabel.Parent = rowFrame
        
        -- Store references
        characterFrames[name] = {
            checkbox = checkbox,
            row = rowFrame,
            statusIndicator = statusIndicator,
            statusLabel = statusLabel,
            countLabel = countLabel,
            timeLabel = timeLabel,
            checkboxFrame = checkboxFrame
        }
        
        -- Add click event to checkbox
        checkbox.MouseButton1Click:Connect(function()
            characterData[name].enabled = not characterData[name].enabled
            
            -- Change checkbox color based on state
            if characterData[name].enabled then
                checkbox.BackgroundColor3 = Color3.fromRGB(76, 175, 80) -- Green when checked
            else
                checkbox.BackgroundColor3 = Color3.fromRGB(158, 158, 158) -- Gray when unchecked
            end
            
            rowFrame.Visible = characterData[name].enabled
            
            -- Save the state in real-time
            local statesToSave = {}
            for _, charName in ipairs(characterNames) do
                statesToSave[charName] = characterData[charName].enabled
            end
            saveCharacterStates(statesToSave)
            
            updateSearchResults() -- Update search results when toggling checkboxes
        end)
    end
    
    -- Update scrolling frame sizes
    charactersScrolling.CanvasSize = UDim2.new(0, 0, 0, #characterNames * 25)
    trackingScrolling.CanvasSize = UDim2.new(0, 0, 0, #characterNames * 28)
    
    -- Remove loading screen and set script as loaded
    loadingFrame:Destroy()
    scriptLoaded = true
    print("Script loaded successfully!")
end

-- Update UI with current data
local function updateUI()
    if not scriptLoaded then return end
    
    local now = tick()
    lastUpdate.Text = "Last updated: " .. os.date("%X")
    
    for _, name in ipairs(characterNames) do
        local data = characterData[name]
        local frames = characterFrames[name]
        
        if not data.enabled then
            frames.row.Visible = false
        else
            frames.row.Visible = true
            
            if data.status == "present" then
                frames.statusIndicator.BackgroundColor3 = Color3.fromRGB(76, 175, 80)
                frames.statusLabel.Text = "Present"
                frames.countLabel.Text = tostring(data.currentCount)
                frames.timeLabel.Text = "Now"
            elseif data.status == "absent" then
                frames.statusIndicator.BackgroundColor3 = Color3.fromRGB(244, 67, 54)
                frames.statusLabel.Text = "Absent"
                frames.countLabel.Text = tostring(data.totalCount)
                
                if data.lastPresentTime then
                    local elapsed = math.floor(now - data.lastPresentTime)
                    local minutes = math.floor(elapsed / 60)
                    local seconds = elapsed % 60
                    frames.timeLabel.Text = string.format("%dm %ds", minutes, seconds)
                else
                    frames.timeLabel.Text = "-"
                end
            else
                frames.statusIndicator.BackgroundColor3 = Color3.fromRGB(158, 158, 158)
                frames.statusLabel.Text = "Never seen"
                frames.countLabel.Text = "0"
                frames.timeLabel.Text = "-"
            end
        end
    end
end

-- Update session time display
local function updateSessionTime()
    if not scriptLoaded then return end
    
    local elapsed = os.time() - joinTime
    local minutes = math.floor(elapsed / 60)
    local seconds = elapsed % 60
    sessionTime.Text = string.format("Session: %dm %ds", minutes, seconds)
end

-- Search functionality - Fixed to properly stack items
local function updateSearchResults()
    if not scriptLoaded then return end
    
    local searchText = string.lower(searchBox.Text)
    
    -- Track visible items for proper positioning
    local visibleCheckboxCount = 0
    local visibleRowCount = 0
    
    for _, name in ipairs(characterNames) do
        local frames = characterFrames[name]
        local isMatch = searchText == "" or 
                       string.find(string.lower(name), searchText, 1, true) or 
                       string.find(string.lower(shortenName(name)), searchText, 1, true)
        
        if isMatch then
            -- Update checkbox position
            frames.checkboxFrame.Visible = true
            frames.checkboxFrame.Position = UDim2.new(0, 10, 0, 5 + visibleCheckboxCount * 25)
            visibleCheckboxCount = visibleCheckboxCount + 1
            
            -- Update row position if enabled
            if characterData[name].enabled then
                frames.row.Visible = true
                frames.row.Position = UDim2.new(0, 5, 0, 5 + visibleRowCount * 28)
                visibleRowCount = visibleRowCount + 1
            else
                frames.row.Visible = false
            end
        else
            frames.checkboxFrame.Visible = false
            frames.row.Visible = false
        end
    end
    
    -- Update scrolling frame canvas sizes based on visible items
    charactersScrolling.CanvasSize = UDim2.new(0, 0, 0, visibleCheckboxCount * 25)
    trackingScrolling.CanvasSize = UDim2.new(0, 0, 0, visibleRowCount * 28)
end

-- Connect search box to update function
searchBox:GetPropertyChangedSignal("Text"):Connect(updateSearchResults)

-- Make the UI draggable
local function makeDraggable(frame, handle)
    local dragging = false
    local dragInput, dragStart, startPos

    local function update(input)
        local delta = input.Position - dragStart
        frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end

    handle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    handle.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)
end

-- Initialize the UI after a short delay to ensure everything is loaded
delay(0.1, initializeUI)

-- Make the UI draggable by its header
makeDraggable(mainFrame, header)

-- Character tracking logic
local seenInstances = {}
local lastAnyPresentTime = {}
local previousCounts = {}

for _, name in ipairs(characterNames) do
    seenInstances[name] = {}
    lastAnyPresentTime[name] = nil
    previousCounts[name] = 0
end

-- Use a more efficient method to find characters
local function getCurrentCharacters()
    local charsFound = {}
    for _, name in ipairs(characterNames) do
        charsFound[name] = {}
        
        -- Find all instances of this character name
        local children = workspace:GetChildren()
        for _, child in ipairs(children) do
            if child.Name == name and child:IsA("Model") then
                table.insert(charsFound[name], child)
            end
        end
    end
    return charsFound
end

-- Auto-buy functions
local function findClosestTarget()
    if not scriptLoaded then return nil, math.huge end
    
    local closestTarget = nil
    local closestDistance = math.huge
    
    for _, characterName in ipairs(characterNames) do
        -- Only target enabled characters
        if characterData[characterName].enabled then
            local target = workspace:FindFirstChild(characterName)
            if target and target:IsA("Model") and target:FindFirstChild("HumanoidRootPart") then
                local distance = (humanoidRootPart.Position - target.HumanoidRootPart.Position).Magnitude
                if distance < closestDistance then
                    closestDistance = distance
                    closestTarget = target
                end
            end
        end
    end
    
    return closestTarget, closestDistance
end

local function pressKey(keyCode, duration)
    isPurchasing = true
    
    -- Key down
    VirtualInputManager:SendKeyEvent(true, keyCode, false, nil)
    
    -- Wait for duration
    local start = tick()
    while tick() - start < duration and autoBuyEnabled do
        RunService.Heartbeat:Wait()
    end
    
    -- Key up
    VirtualInputManager:SendKeyEvent(false, keyCode, false, nil)
    
    isPurchasing = false
end

-- Improved follow function with continuous movement
local function followAndPurchase(target)
    if not scriptLoaded or not target or not humanoid or humanoid.Health <= 0 or isPurchasing then return false end
    
    autoBuyStatus.Text = "Auto-Buy: Following"
    targetStatus.Text = "Target: " .. shortenName(target.Name)
    
    local startTime = tick()
    local lastPosition = target.HumanoidRootPart.Position
    
    -- Follow the target until we're close enough or timeout
    while autoBuyEnabled and (tick() - startTime < maxFollowTime) do
        -- Check if target still exists
        if not target or not target.Parent or not target:FindFirstChild("HumanoidRootPart") then
            autoBuyStatus.Text = "Auto-Buy: Target lost"
            targetStatus.Text = "Target: None"
            return false
        end
        
        -- Calculate distance to target
        local distance = (humanoidRootPart.Position - target.HumanoidRootPart.Position).Magnitude
        
        -- If we're close enough, attempt purchase
        if distance <= purchaseDistance then
            -- Face the target
            humanoidRootPart.CFrame = CFrame.new(
                humanoidRootPart.Position,
                Vector3.new(
                    target.HumanoidRootPart.Position.X,
                    humanoidRootPart.Position.Y,
                    target.HumanoidRootPart.Position.Z
                )
            )
            
            -- Press E to purchase
            autoBuyStatus.Text = "Auto-Buy: Purchasing"
            pressKey(Enum.KeyCode.E, purchaseDuration)
            autoBuyStatus.Text = "Auto-Buy: Purchase complete"
            
            -- Wait a moment after purchase attempt
            wait(1)
            return true
        end
        
        -- Move toward the target's current position (continuous movement)
        humanoid:MoveTo(target.HumanoidRootPart.Position)
        
        -- Check if target is moving away quickly
        local currentPosition = target.HumanoidRootPart.Position
        local targetMovement = (currentPosition - lastPosition).Magnitude
        lastPosition = currentPosition
        
        -- Adjust follow speed based on target movement
        if targetMovement > 2 then  -- If target is moving quickly
            humanoid.WalkSpeed = 22  -- Increase speed to catch up
        else
            humanoid.WalkSpeed = 16  -- Normal speed
        end
        
        -- Update status
        targetStatus.Text = "Target: " .. shortenName(target.Name) .. " (" .. math.floor(distance) .. " studs)"
        
        -- Check for closer targets while following (but don't switch immediately)
        local closestTarget, closestDistance = findClosestTarget()
        if closestTarget and closestTarget ~= target and closestDistance < distance - 5 then
            autoBuyStatus.Text = "Auto-Buy: Switching to closer target"
            targetStatus.Text = "Target: " .. shortenName(closestTarget.Name)
            return false  -- Return false to indicate we should switch targets
        end
        
        -- Wait for next update
        RunService.Heartbeat:Wait()
    end
    
    autoBuyStatus.Text = "Auto-Buy: Timeout"
    targetStatus.Text = "Target: None"
    return false
end

-- Main auto-buy function with improved target prioritization
local function autoBuyLoop()
    while autoBuyEnabled do
        if not scriptLoaded then
            wait(1)
            continue
        end
        
        -- Find the closest target
        local target, distance = findClosestTarget()
        
        if target then
            currentTarget = target
            autoBuyStatus.Text = "Auto-Buy: Target found"
            targetStatus.Text = "Target: " .. shortenName(target.Name) .. " (" .. math.floor(distance) .. " studs)"
            
            -- Follow and attempt to purchase
            local success = followAndPurchase(target)
            
            if success then
                autoBuyStatus.Text = "Auto-Buy: Success"
                -- Wait a bit before looking for next target
                wait(3)
            else
                autoBuyStatus.Text = "Auto-Buy: Failed"
                -- Wait a bit before trying again
                wait(2)
            end
        else
            autoBuyStatus.Text = "Auto-Buy: Searching"
            targetStatus.Text = "Target: None"
            -- Wait longer if no targets found
            wait(3)
        end
    end
end

-- Toggle function for auto-buy
local function toggleAutoBuy()
    if not scriptLoaded then return end
    
    autoBuyEnabled = not autoBuyEnabled
    
    if autoBuyEnabled then
        autoBuyButton.BackgroundColor3 = Color3.fromRGB(53, 220, 53) -- Green when on
        autoBuyStatus.Text = "Auto-Buy: Starting"
        
        -- Start the auto-buy loop
        spawn(autoBuyLoop)
    else
        autoBuyButton.BackgroundColor3 = Color3.fromRGB(220, 53, 53) -- Red when off
        autoBuyStatus.Text = "Auto-Buy: Idle"
        targetStatus.Text = "Target: None"
        
        -- Stop any current movement
        if humanoid then
            humanoid:MoveTo(humanoidRootPart.Position)
        end
    end
end

-- Connect to character added event in case of respawn
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
end)

-- Connect auto-buy button
autoBuyButton.MouseButton1Click:Connect(toggleAutoBuy)

-- Update loop with optimized approach
local lastUpdateTime = 0
local updateInterval = 0.5 -- Update twice per second instead of every frame

local function updateLoop()
    if not scriptLoaded then return end
    
    local currentTime = tick()
    if currentTime - lastUpdateTime < updateInterval then
        return
    end
    lastUpdateTime = currentTime
    
    local currentChars = getCurrentCharacters()

    for _, name in ipairs(characterNames) do
        local instances = currentChars[name] or {}
        local anyPresent = #instances > 0
        local currentCount = #instances

        -- Check if a new instance has appeared and if the character is enabled
        if currentCount > previousCounts[name] and characterData[name].enabled then
            playAlarmSound() -- Play the alarm sound
            
            -- Auto-enable auto-buy if a checked character appears
            if not autoBuyEnabled then
                toggleAutoBuy()
            end
        end
        
        previousCounts[name] = currentCount

        for _, inst in ipairs(instances) do
            if not seenInstances[name][inst] then
                seenInstances[name][inst] = true
                lastAnyPresentTime[name] = tick()
                characterData[name].totalCount = characterData[name].totalCount + 1
            end
        end

        if anyPresent then
            lastAnyPresentTime[name] = tick()
            characterData[name].currentCount = currentCount
            characterData[name].status = "present"
            characterData[name].lastPresentTime = tick()
        else
            if lastAnyPresentTime[name] then
                characterData[name].currentCount = 0
                characterData[name].status = "absent"
            else
                characterData[name].status = "never"
            end
        end
    end
    
    updateUI()
    updateSessionTime()
end

-- Use Heartbeat instead of RenderStepped for better performance
RunService.Heartbeat:Connect(updateLoop)

-- Periodically check for JSON file updates
local lastCheckTime = 0
local jsonCheckInterval = 5 -- Check every 5 seconds

local function checkForJsonUpdates()
    while true do
        wait(jsonCheckInterval)
        
        if not scriptLoaded then
            wait(1)
            continue
        end
        
        -- Reload the JSON file to check for external changes
        local newStates = loadCharacterStates()
        
        -- Apply any changes to the UI
        for name, enabled in pairs(newStates) do
            if characterData[name] and characterData[name].enabled ~= enabled then
                characterData[name].enabled = enabled
                
                -- Update checkbox color
                if characterFrames[name] then
                    characterFrames[name].checkbox.BackgroundColor3 = enabled and Color3.fromRGB(76, 175, 80) or Color3.fromRGB(158, 158, 158)
                    characterFrames[name].row.Visible = enabled
                end
            end
        end
        
        updateSearchResults()
    end
end

-- Start the JSON update checker
spawn(checkForJsonUpdates)

print("Enhanced character tracker with real-time JSON updates loading...")
